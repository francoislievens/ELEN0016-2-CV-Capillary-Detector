"""
[ELEN0016-2]
Fran√ßois Lievens
Julien Hubar
Matthias Pirlet
December 2020

This file plug all the components of our cells
and droplets detector algorithm.
By executing it, all the elements of the given
input data are feed into the algorithm.

Outputs are stored in the result.csv. The first line
contain the distribution of the number of droplets
for each number of cells in it and the following
lines contain all our detected objects with coordinates
and type. In this file are show only elements who fully
appear for the second time.

By default, the inputs folder is 'Original_Dataset'
who contain sub folders with the name of the group
and a video group_x.mp4 (where x is the number of
the group).
the result.csv file is saved in Output_Results/results.csv

If the class variable DEBUG is set to True, we are storing
in the Intermediate_Results/Droplet_Detector the following
jpg files for each input frames:
    - <frame_idx>_a.jpg: the original frame
    - <frame_idx>_b.jpg: the MOG mask
        int both files, bounding boxes are draw when droplets
        are counted (second fully appear)
    - <frame_idx>_c.jpg: The graph of the columns sum who
        are used for the droplet coordinates detection
    - <frame_idx>_d.jpg: When cells are detected: the sub
        frame who is feed to the UNet with as box the
        cell detected
    - <frame_idx>_e.jpg: The mask generated by the UNet
"""

import numpy as np
import time
import matplotlib.pyplot as plt
import os
from ReadingBuffer import ReadingBuffer
from MOG_Filter import MOG_filter
from DropletDetector import DropletDetector
from UNetBuffer import UNetBuffer
from UNetThread import UNetThread


DATA_PATH = 'Original_Dataset'      # Path to the original dataset
UNET_PATH = 'Model'                 # Path to the folder who contain model's weights
UNET_NAME = 'UNet_A'                # Name of the trained UNet to use
EVAL_BUFFER_LOAD = False            # Can be set to True to export the graph who evaluate the filling of buffers

DEVICE = 'cuda'                     # We recomand to use cuda

BUFFER_SIZE = 500
DEBUG = False                       # Active the debugging mode


def counter(video_list):

    # Get all path to target videos
    target_vid = []
    for itm in video_list:
        # Get groupe number
        gp_str = itm[-2:]
        gp = int(gp_str)
        tmp = '{}/images/{}/group{}.mp4'.format(DATA_PATH, itm, gp)
        target_vid.append(tmp)

    # Build the reading buffer
    buff_read = ReadingBuffer(path_list=target_vid,
                              buff_size=BUFFER_SIZE,
                              device=DEVICE)
    # The MOG filter thread
    buff_mog = MOG_filter(input_buffer=buff_read,
                          buff_size=BUFFER_SIZE,
                          device=DEVICE)
    # The Droplet detector/counter
    buff_droplet = DropletDetector(input_buffer=buff_mog,
                                   buff_size=BUFFER_SIZE,
                                   device=DEVICE,
                                   debug=DEBUG)

    # A buffer for the UNet: do the tensorisation step
    buff_UNet = UNetBuffer(input_buffer=buff_droplet,
                           buff_size=BUFFER_SIZE,
                           device=DEVICE,
                           display=False)

    # The UNet thread to count cells
    UNet_thread = UNetThread(input_buffer=buff_UNet,
                             model_path=UNET_PATH,
                             model_name=UNET_NAME,
                             device=DEVICE,
                             batch_size=10,
                             debug=DEBUG)
    start_time = time.time()
    buff_read.start()
    buff_mog.start()
    buff_droplet.start()
    buff_UNet.start()
    UNet_thread.start()


    # Filling track
    fill_reader = []
    fill_mog = []
    fill_drp_counter = []
    fill_UNet_buff = []
    while not UNet_thread.end:
    #for i in range(200):

        if EVAL_BUFFER_LOAD:
            fill_reader.append(buff_read.buffer.qsize())
            fill_mog.append(buff_mog.buffer.qsize())
            fill_drp_counter.append(buff_droplet.buffer.qsize())
            fill_UNet_buff.append(buff_UNet.buffer.qsize())

        time.sleep(0.1)

    end_time = time.time()
    if EVAL_BUFFER_LOAD:
        x_axis = np.arange(len(fill_reader))
        plt.plot(x_axis, fill_reader, label='Reader Buffer', color='Green', linewidth=0.5)
        plt.plot(x_axis, fill_mog, label='MOG buffer', color='Blue', linewidth=0.5)
        plt.plot(x_axis, fill_drp_counter, label='Droplet counter buffer', color='Red', linewidth=0.5)
        plt.plot(x_axis, fill_UNet_buff, label='UNet buffer', color='Purple', linewidth=0.5)
        plt.legend()
        plt.yscale('log')
        plt.title('Buffer load')
        plt.show()
        plt.close()

    print('Counted droplets: {}'.format(buff_droplet.drop_counter))
    print('Counted cells: {}'.format(UNet_thread.total_cell))
    print('Computing Time: {}'.format(end_time - start_time))
    total_frame_idx = buff_read.frame_idx
    print('Readed frames: {}'.format(total_frame_idx))
    print('FPS: {}'.format(total_frame_idx / (end_time - start_time)))

    # Histogram part
    nb_zero_cell = buff_droplet.drop_counter - np.sum(UNet_thread.histogram)
    UNet_thread.histogram[0] = nb_zero_cell
    histo = []
    for itm in UNet_thread.histogram.tolist():
        histo.append(str(int(itm)))
    file = open('Output_Results/results.csv', 'w')
    file.write(','.join(histo))
    file.write('\n')
    file.close()

    # Write final results
    results_drp = buff_droplet.final_results
    results_cell = UNet_thread.final_results

    to_print = []
    for i in range(0, total_frame_idx):
        # To compute absolute coordinates of the cell later
        x_start = 0
        for j in range(0, len(results_drp)):
            if results_drp[j][0] == i:
                to_print.append('frame_{},{},0,{},240,droplet'.format(i,
                                                                        results_drp[j][1],
                                                                        results_drp[j][2]))
                x_start = results_drp[j][1]
        for j in range(0, len(results_cell)):
            if results_cell[j][0] == i:
                to_print.append('frame_{},{},{},{},{},cell'.format(i,
                                                                     results_cell[j][3]-20+x_start,
                                                                     results_cell[j][4]-20,
                                                                     results_cell[j][3]+20+x_start,
                                                                     results_cell[j][4]+20))
    file = open('Output_results/results.csv', 'a')
    file.write('\n'.join(to_print))
    file.close()

if __name__ == '__main__':

    # Get the list of all data in the original dataset
    video_list = os.listdir('Original_Dataset/images')

    print('* ------------------------------------------------ *')
    print('* Input video list:')
    for itm in video_list:
        print('* {}'.format(itm))
    print('* ------------------------------------------------ *')

    counter(video_list)